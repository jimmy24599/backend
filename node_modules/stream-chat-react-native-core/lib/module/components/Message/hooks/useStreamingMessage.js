var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useStreamingMessage = void 0;
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _react = require("react");
var DEFAULT_LETTER_INTERVAL = 0;
var DEFAULT_RENDERING_LETTER_COUNT = 2;
var useStreamingMessage = exports.useStreamingMessage = function useStreamingMessage(_ref) {
  var _ref$letterInterval = _ref.letterInterval,
    letterInterval = _ref$letterInterval === void 0 ? DEFAULT_LETTER_INTERVAL : _ref$letterInterval,
    _ref$renderingLetterC = _ref.renderingLetterCount,
    renderingLetterCount = _ref$renderingLetterC === void 0 ? DEFAULT_RENDERING_LETTER_COUNT : _ref$renderingLetterC,
    text = _ref.text;
  var _useState = (0, _react.useState)(text),
    _useState2 = (0, _slicedToArray2["default"])(_useState, 2),
    streamedMessageText = _useState2[0],
    setStreamedMessageText = _useState2[1];
  var textCursor = (0, _react.useRef)(text.length);
  (0, _react.useEffect)(function () {
    var textLength = text.length;
    var interval = setInterval(function () {
      if (!text || textCursor.current >= textLength) {
        clearInterval(interval);
      }
      var newCursorValue = textCursor.current + renderingLetterCount;
      var newText = text.substring(0, newCursorValue);
      textCursor.current += newText.length - textCursor.current;
      var codeBlockCounts = (newText.match(/```/g) || []).length;
      var shouldOptimisticallyCloseCodeBlock = codeBlockCounts > 0 && codeBlockCounts % 2 > 0;
      setStreamedMessageText(shouldOptimisticallyCloseCodeBlock ? newText + '```' : newText);
    }, letterInterval);
    return function () {
      clearInterval(interval);
    };
  }, [letterInterval, renderingLetterCount, text]);
  return {
    streamedMessageText: streamedMessageText
  };
};
//# sourceMappingURL=useStreamingMessage.js.map