var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ReactionListTopItem = exports.ReactionListTop = void 0;
var _react = _interopRequireDefault(require("react"));
var _reactNative = require("react-native");
var _MessageContext = require("../../../../contexts/messageContext/MessageContext");
var _MessagesContext = require("../../../../contexts/messagesContext/MessagesContext");
var _ThemeContext = require("../../../../contexts/themeContext/ThemeContext");
var _Unknown = require("../../../../icons/Unknown");
var _jsxRuntime = require("react/jsx-runtime");
var _this = this,
  _jsxFileName = "/home/runner/work/stream-chat-react-native/stream-chat-react-native/package/src/components/Message/MessageSimple/ReactionList/ReactionListTop.tsx";
var Icon = function Icon(_ref) {
  var _supportedReactions$f;
  var pathFill = _ref.pathFill,
    size = _ref.size,
    style = _ref.style,
    supportedReactions = _ref.supportedReactions,
    type = _ref.type;
  var ReactionIcon = (supportedReactions == null || (_supportedReactions$f = supportedReactions.find(function (reaction) {
    return reaction.type === type;
  })) == null ? void 0 : _supportedReactions$f.Icon) || _Unknown.Unknown;
  return (0, _jsxRuntime.jsx)(_reactNative.View, {
    children: (0, _jsxRuntime.jsx)(ReactionIcon, {
      height: size,
      pathFill: pathFill,
      style: style,
      width: size
    })
  });
};
var ReactionListTopItem = exports.ReactionListTopItem = function ReactionListTopItem(props) {
  var index = props.index,
    reaction = props.reaction,
    reactions = props.reactions,
    supportedReactions = props.supportedReactions;
  var _useTheme = (0, _ThemeContext.useTheme)(),
    _useTheme$theme$messa = _useTheme.theme.messageSimple.reactionListTop.item,
    container = _useTheme$theme$messa.container,
    icon = _useTheme$theme$messa.icon,
    iconFillColor = _useTheme$theme$messa.iconFillColor,
    iconUnFillColor = _useTheme$theme$messa.iconUnFillColor,
    reactionSize = _useTheme$theme$messa.reactionSize;
  var reactionsLength = reactions ? reactions.length : 0;
  return (0, _jsxRuntime.jsx)(_reactNative.View, {
    style: [styles.reactionContainer, {
      marginRight: index < reactionsLength - 1 ? 5 : 0
    }, container],
    children: (0, _jsxRuntime.jsx)(Icon, {
      pathFill: reaction.own ? iconFillColor : iconUnFillColor,
      size: reactionSize / 2,
      style: icon,
      supportedReactions: supportedReactions,
      type: reaction.type
    }, reaction.type)
  }, reaction.type);
};
var ReactionListTop = exports.ReactionListTop = function ReactionListTop(props) {
  var propAlignment = props.alignment,
    propFill = props.fill,
    propHasReactions = props.hasReactions,
    messageContentWidth = props.messageContentWidth,
    propOnLongPress = props.onLongPress,
    propOnPress = props.onPress,
    propOnPressIn = props.onPressIn,
    propPreventPress = props.preventPress,
    propReactions = props.reactions,
    propReactionSize = props.reactionSize,
    propShowMessageOverlay = props.showMessageOverlay,
    propSupportedReactions = props.supportedReactions;
  var _useMessageContext = (0, _MessageContext.useMessageContext)(),
    contextAlignment = _useMessageContext.alignment,
    contextHasReactions = _useMessageContext.hasReactions,
    contextOnLongPress = _useMessageContext.onLongPress,
    contextOnPress = _useMessageContext.onPress,
    contextOnPressIn = _useMessageContext.onPressIn,
    contextPreventPress = _useMessageContext.preventPress,
    contextReactions = _useMessageContext.reactions,
    contextShowMessageOverlay = _useMessageContext.showMessageOverlay;
  var _useMessagesContext = (0, _MessagesContext.useMessagesContext)(),
    contextSupportedReactions = _useMessagesContext.supportedReactions;
  var alignment = propAlignment || contextAlignment;
  var hasReactions = propHasReactions || contextHasReactions;
  var _onLongPress = propOnLongPress || contextOnLongPress;
  var _onPress = propOnPress || contextOnPress;
  var _onPressIn = propOnPressIn || contextOnPressIn;
  var preventPress = propPreventPress || contextPreventPress;
  var reactions = propReactions || contextReactions;
  var showMessageOverlay = propShowMessageOverlay || contextShowMessageOverlay;
  var supportedReactions = propSupportedReactions || contextSupportedReactions;
  var _useTheme2 = (0, _ThemeContext.useTheme)(),
    _useTheme2$theme = _useTheme2.theme,
    _useTheme2$theme$colo = _useTheme2$theme.colors,
    grey_gainsboro = _useTheme2$theme$colo.grey_gainsboro,
    grey_whisper = _useTheme2$theme$colo.grey_whisper,
    white = _useTheme2$theme$colo.white,
    _useTheme2$theme$mess = _useTheme2$theme.messageSimple.reactionListTop,
    container = _useTheme2$theme$mess.container,
    themeReactionSize = _useTheme2$theme$mess.item.reactionSize,
    reactionPosition = _useTheme2$theme$mess.position;
  var supportedReactionTypes = supportedReactions == null ? void 0 : supportedReactions.map(function (supportedReaction) {
    return supportedReaction.type;
  });
  var hasSupportedReactions = reactions.some(function (reaction) {
    return supportedReactionTypes == null ? void 0 : supportedReactionTypes.includes(reaction.type);
  });
  if (!hasSupportedReactions || messageContentWidth === 0 || !hasReactions) {
    return null;
  }
  var alignmentLeft = alignment === 'left';
  var fill = propFill || (alignmentLeft ? grey_gainsboro : grey_whisper);
  var reactionSize = propReactionSize || themeReactionSize;
  var SMALL_MESSAGE_LENGTH_THRESHOLD = 80;
  var totalReactionSize = reactionSize * reactions.length;
  var halfReactionSize = totalReactionSize / 2;
  var position = messageContentWidth < SMALL_MESSAGE_LENGTH_THRESHOLD ? messageContentWidth - reactionPosition : messageContentWidth - halfReactionSize;
  return (0, _jsxRuntime.jsx)(_reactNative.TouchableOpacity, {
    accessibilityLabel: "Reaction List Top",
    disabled: preventPress,
    onLongPress: function onLongPress(event) {
      if (_onLongPress) {
        _onLongPress({
          emitter: 'reactionList',
          event: event
        });
      }
    },
    onPress: function onPress(event) {
      if (_onPress) {
        _onPress({
          defaultHandler: function defaultHandler() {
            return showMessageOverlay(true);
          },
          emitter: 'reactionList',
          event: event
        });
      }
    },
    onPressIn: function onPressIn(event) {
      if (_onPressIn) {
        _onPressIn({
          defaultHandler: function defaultHandler() {
            return showMessageOverlay(true);
          },
          emitter: 'reactionList',
          event: event
        });
      }
    },
    style: [styles.container, {
      backgroundColor: fill,
      borderColor: white,
      borderRadius: reactionSize,
      height: reactionSize,
      top: -reactionPosition
    }, alignmentLeft ? {
      left: position
    } : {
      right: position
    }, container],
    children: reactions.map(function (reaction, index) {
      return (0, _jsxRuntime.jsx)(ReactionListTopItem, {
        index: index,
        reaction: reaction,
        reactions: reactions,
        supportedReactions: supportedReactions
      }, reaction.type);
    })
  });
};
var styles = _reactNative.StyleSheet.create({
  container: {
    alignItems: 'center',
    borderWidth: 1,
    flexDirection: 'row',
    justifyContent: 'space-evenly',
    paddingHorizontal: 5,
    position: 'absolute'
  },
  reactionContainer: {
    alignItems: 'center',
    flexDirection: 'row',
    justifyContent: 'center'
  },
  reactionCount: {
    fontSize: 12,
    fontWeight: 'bold',
    marginLeft: 2
  }
});
//# sourceMappingURL=ReactionListTop.js.map