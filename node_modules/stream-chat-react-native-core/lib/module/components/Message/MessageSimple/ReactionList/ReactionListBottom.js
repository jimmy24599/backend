var _typeof = require("@babel/runtime/helpers/typeof");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ReactionListBottomItem = exports.ReactionListBottom = void 0;
var _react = _interopRequireWildcard(require("react"));
var _reactNative = require("react-native");
var _MessageContext = require("../../../../contexts/messageContext/MessageContext");
var _MessagesContext = require("../../../../contexts/messagesContext/MessagesContext");
var _ThemeContext = require("../../../../contexts/themeContext/ThemeContext");
var _Unknown = require("../../../../icons/Unknown");
var _jsxRuntime = require("react/jsx-runtime");
var _this = this,
  _jsxFileName = "/home/runner/work/stream-chat-react-native/stream-chat-react-native/package/src/components/Message/MessageSimple/ReactionList/ReactionListBottom.tsx";
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != _typeof(e) && "function" != typeof e) return { "default": e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n["default"] = e, t && t.set(e, n), n; }
var Icon = function Icon(_ref) {
  var _supportedReactions$f;
  var pathFill = _ref.pathFill,
    size = _ref.size,
    style = _ref.style,
    supportedReactions = _ref.supportedReactions,
    type = _ref.type;
  var ReactionIcon = (supportedReactions == null || (_supportedReactions$f = supportedReactions.find(function (reaction) {
    return reaction.type === type;
  })) == null ? void 0 : _supportedReactions$f.Icon) || _Unknown.Unknown;
  return (0, _jsxRuntime.jsx)(ReactionIcon, {
    height: size,
    pathFill: pathFill,
    style: style,
    width: size
  });
};
var ReactionListBottomItem = exports.ReactionListBottomItem = function ReactionListBottomItem(props) {
  var handleReaction = props.handleReaction,
    _onLongPress = props.onLongPress,
    _onPress = props.onPress,
    _onPressIn = props.onPressIn,
    preventPress = props.preventPress,
    reaction = props.reaction,
    showMessageOverlay = props.showMessageOverlay,
    supportedReactions = props.supportedReactions;
  var scaleValue = (0, _react.useRef)(new _reactNative.Animated.Value(1)).current;
  var _useTheme = (0, _ThemeContext.useTheme)(),
    _useTheme$theme = _useTheme.theme,
    _useTheme$theme$color = _useTheme$theme.colors,
    black = _useTheme$theme$color.black,
    grey_gainsboro = _useTheme$theme$color.grey_gainsboro,
    light_blue = _useTheme$theme$color.light_blue,
    _useTheme$theme$messa = _useTheme$theme.messageSimple.reactionListBottom.item,
    container = _useTheme$theme$messa.container,
    countText = _useTheme$theme$messa.countText,
    icon = _useTheme$theme$messa.icon,
    iconFillColor = _useTheme$theme$messa.iconFillColor,
    iconSize = _useTheme$theme$messa.iconSize,
    iconUnFillColor = _useTheme$theme$messa.iconUnFillColor;
  var onPressInAnimation = (0, _react.useCallback)(function () {
    _reactNative.Animated.spring(scaleValue, {
      toValue: 0.8,
      useNativeDriver: true
    }).start();
  }, [scaleValue]);
  var onPressOutAnimation = (0, _react.useCallback)(function () {
    _reactNative.Animated.spring(scaleValue, {
      toValue: 1,
      useNativeDriver: true
    }).start();
  }, [scaleValue]);
  return (0, _jsxRuntime.jsx)(_reactNative.Pressable, {
    accessibilityLabel: "Reaction List Bottom Item",
    disabled: preventPress,
    onLongPress: function onLongPress(event) {
      if (_onLongPress) {
        _onLongPress({
          defaultHandler: function defaultHandler() {
            if (showMessageOverlay) {
              showMessageOverlay(true, reaction.type);
            }
          },
          emitter: 'reactionList',
          event: event
        });
      }
    },
    onPress: function onPress(event) {
      if (_onPress) {
        _onPress({
          defaultHandler: function defaultHandler() {
            if (handleReaction) {
              handleReaction(reaction.type);
            }
          },
          emitter: 'reactionList',
          event: event
        });
      }
    },
    onPressIn: function onPressIn(event) {
      onPressInAnimation();
      if (_onPressIn) {
        _onPressIn({
          defaultHandler: function defaultHandler() {
            if (handleReaction) {
              handleReaction(reaction.type);
            }
          },
          emitter: 'reactionList',
          event: event
        });
      }
    },
    onPressOut: onPressOutAnimation,
    children: (0, _jsxRuntime.jsxs)(_reactNative.Animated.View, {
      style: [styles.itemContainer, {
        backgroundColor: reaction.own ? light_blue : grey_gainsboro,
        transform: [{
          scale: scaleValue
        }]
      }, container],
      children: [(0, _jsxRuntime.jsx)(Icon, {
        pathFill: reaction.own ? iconFillColor : iconUnFillColor,
        size: iconSize,
        style: icon,
        supportedReactions: supportedReactions,
        type: reaction.type
      }, reaction.type), (0, _jsxRuntime.jsx)(_reactNative.Text, {
        style: [styles.reactionCount, {
          color: black
        }, countText],
        children: reaction.count
      })]
    })
  }, reaction.type);
};
var renderItem = function renderItem(_ref2) {
  var index = _ref2.index,
    item = _ref2.item;
  return (0, _jsxRuntime.jsx)(ReactionListBottomItem, {
    handleReaction: item.handleReaction,
    onLongPress: item.onLongPress,
    onPress: item.onPress,
    onPressIn: item.onPressIn,
    preventPress: item.preventPress,
    reaction: item.reaction,
    showMessageOverlay: item.showMessageOverlay,
    supportedReactions: item.supportedReactions
  }, index);
};
var ReactionListBottom = exports.ReactionListBottom = function ReactionListBottom(props) {
  var propHandlerReaction = props.handleReaction,
    propHasReactions = props.hasReactions,
    propOnLongPress = props.onLongPress,
    propOnPress = props.onPress,
    propOnPressIn = props.onPressIn,
    propPreventPress = props.preventPress,
    propReactions = props.reactions,
    propShowMessageOverlay = props.showMessageOverlay,
    propSupportedReactions = props.supportedReactions;
  var _useMessageContext = (0, _MessageContext.useMessageContext)(),
    contextHandleReaction = _useMessageContext.handleReaction,
    contextHasReactions = _useMessageContext.hasReactions,
    contextOnLongPress = _useMessageContext.onLongPress,
    contextOnPress = _useMessageContext.onPress,
    contextOnPressIn = _useMessageContext.onPressIn,
    contextPreventPress = _useMessageContext.preventPress,
    contextReactions = _useMessageContext.reactions,
    contextShowMessageOverlay = _useMessageContext.showMessageOverlay;
  var _useMessagesContext = (0, _MessagesContext.useMessagesContext)(),
    contextSupportedReactions = _useMessagesContext.supportedReactions;
  var handleReaction = propHandlerReaction || contextHandleReaction;
  var hasReactions = propHasReactions || contextHasReactions;
  var onLongPress = propOnLongPress || contextOnLongPress;
  var onPress = propOnPress || contextOnPress;
  var onPressIn = propOnPressIn || contextOnPressIn;
  var preventPress = propPreventPress || contextPreventPress;
  var reactions = propReactions || contextReactions;
  var showMessageOverlay = propShowMessageOverlay || contextShowMessageOverlay;
  var supportedReactions = propSupportedReactions || contextSupportedReactions;
  var _useTheme2 = (0, _ThemeContext.useTheme)(),
    contentContainer = _useTheme2.theme.messageSimple.reactionListBottom.contentContainer;
  var supportedReactionTypes = supportedReactions == null ? void 0 : supportedReactions.map(function (supportedReaction) {
    return supportedReaction.type;
  });
  var hasSupportedReactions = reactions.some(function (reaction) {
    return supportedReactionTypes == null ? void 0 : supportedReactionTypes.includes(reaction.type);
  });
  if (!hasSupportedReactions || !hasReactions) {
    return null;
  }
  var reactionListBottomItemData = reactions.map(function (reaction) {
    return {
      handleReaction: handleReaction,
      onLongPress: onLongPress,
      onPress: onPress,
      onPressIn: onPressIn,
      preventPress: preventPress,
      reaction: reaction,
      showMessageOverlay: showMessageOverlay,
      supportedReactions: supportedReactions
    };
  });
  return (0, _jsxRuntime.jsx)(_reactNative.FlatList, {
    accessibilityLabel: "Reaction List Bottom",
    contentContainerStyle: [styles.contentContainer, contentContainer],
    data: reactionListBottomItemData,
    keyExtractor: function keyExtractor(item) {
      return item.reaction.type;
    },
    numColumns: 6,
    renderItem: renderItem,
    showsHorizontalScrollIndicator: false,
    showsVerticalScrollIndicator: false
  });
};
var styles = _reactNative.StyleSheet.create({
  contentContainer: {
    alignSelf: 'flex-end'
  },
  itemContainer: {
    alignItems: 'center',
    borderRadius: 12,
    flexDirection: 'row',
    justifyContent: 'center',
    margin: 2,
    padding: 8
  },
  reactionCount: {
    fontWeight: '600',
    marginLeft: 4
  }
});
//# sourceMappingURL=ReactionListBottom.js.map