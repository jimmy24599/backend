var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useMessageListPagination = void 0;
var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
var _react = require("react");
var _debounce = _interopRequireDefault(require("lodash/debounce"));
var _useChannelDataState = require("./useChannelDataState");
var _utils = require("../../../utils/utils");
var defaultDebounceInterval = 500;
var debounceOptions = {
  leading: true,
  trailing: true
};
var useMessageListPagination = exports.useMessageListPagination = function useMessageListPagination(_ref) {
  var channel = _ref.channel;
  var _useChannelMessageDat = (0, _useChannelDataState.useChannelMessageDataState)(channel),
    copyMessagesStateFromChannel = _useChannelMessageDat.copyMessagesStateFromChannel,
    jumpToLatestMessage = _useChannelMessageDat.jumpToLatestMessage,
    jumpToMessageFinished = _useChannelMessageDat.jumpToMessageFinished,
    loadInitialMessagesStateFromChannel = _useChannelMessageDat.loadInitialMessagesStateFromChannel,
    loadMoreFinishedFn = _useChannelMessageDat.loadMoreFinished,
    loadMoreRecentFinishedFn = _useChannelMessageDat.loadMoreRecentFinished,
    setLoading = _useChannelMessageDat.setLoading,
    setLoadingMore = _useChannelMessageDat.setLoadingMore,
    setLoadingMoreRecent = _useChannelMessageDat.setLoadingMoreRecent,
    state = _useChannelMessageDat.state;
  var loadMoreFinished = (0, _react.useRef)((0, _debounce["default"])(function (hasMore, messages) {
    loadMoreFinishedFn(hasMore, messages);
  }, defaultDebounceInterval, debounceOptions)).current;
  var loadMoreRecentFinished = (0, _react.useRef)((0, _debounce["default"])(function (hasMore, newMessages) {
    loadMoreRecentFinishedFn(hasMore, newMessages);
  }, defaultDebounceInterval, debounceOptions)).current;
  var loadLatestMessages = function () {
    var _ref2 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee() {
      return _regenerator["default"].wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            _context.prev = 0;
            setLoading(true);
            _context.next = 4;
            return channel.state.loadMessageIntoState('latest');
          case 4:
            loadMoreFinished(channel.state.messagePagination.hasPrev, channel.state.messages);
            jumpToLatestMessage();
            _context.next = 11;
            break;
          case 8:
            _context.prev = 8;
            _context.t0 = _context["catch"](0);
            console.warn('Loading latest messages failed with error:', _context.t0);
          case 11:
          case "end":
            return _context.stop();
        }
      }, _callee, null, [[0, 8]]);
    }));
    return function loadLatestMessages() {
      return _ref2.apply(this, arguments);
    };
  }();
  var loadMore = function () {
    var _ref3 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee2() {
      var _state$messages;
      var limit,
        oldestMessage,
        oldestID,
        _args2 = arguments;
      return _regenerator["default"].wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            limit = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : 20;
            if (channel.state.messagePagination.hasPrev) {
              _context2.next = 3;
              break;
            }
            return _context2.abrupt("return");
          case 3:
            if (!(state.loadingMore || state.loadingMoreRecent)) {
              _context2.next = 5;
              break;
            }
            return _context2.abrupt("return");
          case 5:
            setLoadingMore(true);
            oldestMessage = (_state$messages = state.messages) == null ? void 0 : _state$messages[0];
            oldestID = oldestMessage == null ? void 0 : oldestMessage.id;
            _context2.prev = 8;
            _context2.next = 11;
            return channel.query({
              messages: {
                id_lt: oldestID,
                limit: limit
              },
              watchers: {
                limit: limit
              }
            });
          case 11:
            loadMoreFinished(channel.state.messagePagination.hasPrev, channel.state.messages);
            setLoadingMore(false);
            _context2.next = 19;
            break;
          case 15:
            _context2.prev = 15;
            _context2.t0 = _context2["catch"](8);
            setLoadingMore(false);
            console.warn('Message pagination(fetching old messages) request failed with error:', _context2.t0);
          case 19:
          case "end":
            return _context2.stop();
        }
      }, _callee2, null, [[8, 15]]);
    }));
    return function loadMore() {
      return _ref3.apply(this, arguments);
    };
  }();
  var loadMoreRecent = function () {
    var _ref4 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee3() {
      var _state$messages2;
      var limit,
        newestMessage,
        newestID,
        _args3 = arguments;
      return _regenerator["default"].wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            limit = _args3.length > 0 && _args3[0] !== undefined ? _args3[0] : 10;
            if (channel.state.messagePagination.hasNext) {
              _context3.next = 3;
              break;
            }
            return _context3.abrupt("return");
          case 3:
            if (!(state.loadingMore || state.loadingMoreRecent)) {
              _context3.next = 5;
              break;
            }
            return _context3.abrupt("return");
          case 5:
            setLoadingMoreRecent(true);
            newestMessage = (_state$messages2 = state.messages) == null ? void 0 : _state$messages2[(state == null ? void 0 : state.messages.length) - 1];
            newestID = newestMessage == null ? void 0 : newestMessage.id;
            _context3.prev = 8;
            _context3.next = 11;
            return channel.query({
              messages: {
                id_gt: newestID,
                limit: limit
              },
              watchers: {
                limit: limit
              }
            });
          case 11:
            loadMoreRecentFinished(channel.state.messagePagination.hasNext, channel.state.messages);
            _context3.next = 19;
            break;
          case 14:
            _context3.prev = 14;
            _context3.t0 = _context3["catch"](8);
            setLoadingMoreRecent(false);
            console.warn('Message pagination(fetching new messages) request failed with error:', _context3.t0);
            return _context3.abrupt("return");
          case 19:
          case "end":
            return _context3.stop();
        }
      }, _callee3, null, [[8, 14]]);
    }));
    return function loadMoreRecent() {
      return _ref4.apply(this, arguments);
    };
  }();
  var loadChannelAroundMessage = function () {
    var _ref6 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee4(_ref5) {
      var _ref5$limit, limit, messageIdToLoadAround, setTargetedMessage;
      return _regenerator["default"].wrap(function _callee4$(_context4) {
        while (1) switch (_context4.prev = _context4.next) {
          case 0:
            _ref5$limit = _ref5.limit, limit = _ref5$limit === void 0 ? 25 : _ref5$limit, messageIdToLoadAround = _ref5.messageId, setTargetedMessage = _ref5.setTargetedMessage;
            if (messageIdToLoadAround) {
              _context4.next = 3;
              break;
            }
            return _context4.abrupt("return");
          case 3:
            setLoadingMore(true);
            setLoading(true);
            _context4.prev = 5;
            _context4.next = 8;
            return channel.state.loadMessageIntoState(messageIdToLoadAround, undefined, limit);
          case 8:
            loadMoreFinished(channel.state.messagePagination.hasPrev, channel.state.messages);
            jumpToMessageFinished(channel.state.messagePagination.hasNext, messageIdToLoadAround);
            if (setTargetedMessage) {
              setTargetedMessage(messageIdToLoadAround);
            }
            _context4.next = 19;
            break;
          case 13:
            _context4.prev = 13;
            _context4.t0 = _context4["catch"](5);
            setLoadingMore(false);
            setLoading(false);
            console.warn('Message pagination(fetching messages in the channel around a message id) request failed with error:', _context4.t0);
            return _context4.abrupt("return");
          case 19:
          case "end":
            return _context4.stop();
        }
      }, _callee4, null, [[5, 13]]);
    }));
    return function loadChannelAroundMessage(_x) {
      return _ref6.apply(this, arguments);
    };
  }();
  var fetchMessagesAround = function () {
    var _ref7 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee5(channel, timestamp, limit) {
      var _yield$channel$query, messages;
      return _regenerator["default"].wrap(function _callee5$(_context5) {
        while (1) switch (_context5.prev = _context5.next) {
          case 0:
            _context5.prev = 0;
            _context5.next = 3;
            return channel.query({
              messages: {
                created_at_around: timestamp,
                limit: limit
              }
            }, 'new');
          case 3:
            _yield$channel$query = _context5.sent;
            messages = _yield$channel$query.messages;
            return _context5.abrupt("return", messages);
          case 8:
            _context5.prev = 8;
            _context5.t0 = _context5["catch"](0);
            console.error('Error fetching messages around timestamp:', _context5.t0);
            throw _context5.t0;
          case 12:
          case "end":
            return _context5.stop();
        }
      }, _callee5, null, [[0, 8]]);
    }));
    return function fetchMessagesAround(_x2, _x3, _x4) {
      return _ref7.apply(this, arguments);
    };
  }();
  var loadChannelAtFirstUnreadMessage = function () {
    var _ref9 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee6(_ref8) {
      var channelUnreadState, _ref8$limit, limit, setChannelUnreadState, setTargetedMessage, first_unread_message_id, last_read, last_read_message_id, firstUnreadMessageId, lastReadMessageId, isInCurrentMessageSet, messagesState, messageIdx, _messagesState, _messageIdx, lastReadTimestamp, _findInMessagesByDate, lastReadIdx, lastReadMessage, messages, firstMessageWithCreationDate, firstMessageTimestamp, _result$message, result, targetedMessage, indexOfTarget;
      return _regenerator["default"].wrap(function _callee6$(_context6) {
        while (1) switch (_context6.prev = _context6.next) {
          case 0:
            channelUnreadState = _ref8.channelUnreadState, _ref8$limit = _ref8.limit, limit = _ref8$limit === void 0 ? 25 : _ref8$limit, setChannelUnreadState = _ref8.setChannelUnreadState, setTargetedMessage = _ref8.setTargetedMessage;
            _context6.prev = 1;
            if (channelUnreadState != null && channelUnreadState.unread_messages) {
              _context6.next = 4;
              break;
            }
            return _context6.abrupt("return");
          case 4:
            first_unread_message_id = channelUnreadState.first_unread_message_id, last_read = channelUnreadState.last_read, last_read_message_id = channelUnreadState.last_read_message_id;
            firstUnreadMessageId = first_unread_message_id;
            lastReadMessageId = last_read_message_id;
            isInCurrentMessageSet = false;
            messagesState = channel.state.messages;
            if (!firstUnreadMessageId) {
              _context6.next = 14;
              break;
            }
            messageIdx = (0, _utils.findInMessagesById)(messagesState, firstUnreadMessageId);
            isInCurrentMessageSet = messageIdx !== -1;
            _context6.next = 49;
            break;
          case 14:
            if (!lastReadMessageId) {
              _context6.next = 20;
              break;
            }
            _messageIdx = (0, _utils.findInMessagesById)(messagesState, lastReadMessageId);
            isInCurrentMessageSet = _messageIdx !== -1;
            firstUnreadMessageId = _messageIdx > -1 ? (_messagesState = messagesState[_messageIdx + 1]) == null ? void 0 : _messagesState.id : undefined;
            _context6.next = 49;
            break;
          case 20:
            lastReadTimestamp = last_read.getTime();
            _findInMessagesByDate = (0, _utils.findInMessagesByDate)(messagesState, last_read), lastReadIdx = _findInMessagesByDate.index, lastReadMessage = _findInMessagesByDate.message;
            if (!lastReadMessage) {
              _context6.next = 28;
              break;
            }
            lastReadMessageId = lastReadMessage.id;
            firstUnreadMessageId = messagesState[lastReadIdx + 1].id;
            isInCurrentMessageSet = !!firstUnreadMessageId;
            _context6.next = 49;
            break;
          case 28:
            setLoadingMore(true);
            setLoading(true);
            _context6.prev = 30;
            _context6.next = 33;
            return fetchMessagesAround(channel, last_read.toISOString(), limit);
          case 33:
            messages = _context6.sent;
            _context6.next = 42;
            break;
          case 36:
            _context6.prev = 36;
            _context6.t0 = _context6["catch"](30);
            setLoading(false);
            loadMoreFinished(channel.state.messagePagination.hasPrev, messagesState);
            console.log('Loading channel at first unread message failed with error:', _context6.t0);
            return _context6.abrupt("return");
          case 42:
            firstMessageWithCreationDate = messages.find(function (msg) {
              return msg.created_at;
            });
            if (firstMessageWithCreationDate) {
              _context6.next = 46;
              break;
            }
            loadMoreFinished(channel.state.messagePagination.hasPrev, channel.state.messages);
            throw new Error('Failed to jump to first unread message id.');
          case 46:
            firstMessageTimestamp = new Date(firstMessageWithCreationDate.created_at).getTime();
            if (lastReadTimestamp < firstMessageTimestamp) {
              firstUnreadMessageId = firstMessageWithCreationDate.id;
            } else {
              result = (0, _utils.findInMessagesByDate)(messages, last_read);
              lastReadMessageId = (_result$message = result.message) == null ? void 0 : _result$message.id;
            }
            loadMoreFinished(channel.state.messagePagination.hasPrev, channel.state.messages);
          case 49:
            if (!(!firstUnreadMessageId && !lastReadMessageId)) {
              _context6.next = 51;
              break;
            }
            throw new Error('Failed to jump to first unread message id.');
          case 51:
            if (isInCurrentMessageSet) {
              _context6.next = 69;
              break;
            }
            _context6.prev = 52;
            setLoadingMore(true);
            setLoading(true);
            targetedMessage = firstUnreadMessageId || lastReadMessageId;
            _context6.next = 58;
            return channel.state.loadMessageIntoState(targetedMessage, undefined, limit);
          case 58:
            indexOfTarget = channel.state.messages.findIndex(function (message) {
              return message.id === targetedMessage;
            });
            loadMoreFinished(channel.state.messagePagination.hasPrev, channel.state.messages);
            firstUnreadMessageId = firstUnreadMessageId != null ? firstUnreadMessageId : channel.state.messages[indexOfTarget + 1].id;
            _context6.next = 69;
            break;
          case 63:
            _context6.prev = 63;
            _context6.t1 = _context6["catch"](52);
            setLoading(false);
            loadMoreFinished(channel.state.messagePagination.hasPrev, channel.state.messages);
            console.log('Loading channel at first unread message failed with error:', _context6.t1);
            return _context6.abrupt("return");
          case 69:
            if (firstUnreadMessageId) {
              _context6.next = 71;
              break;
            }
            throw new Error('Failed to jump to first unread message id.');
          case 71:
            if (!first_unread_message_id && setChannelUnreadState) {
              setChannelUnreadState(Object.assign({}, channelUnreadState, {
                first_unread_message_id: firstUnreadMessageId,
                last_read_message_id: lastReadMessageId
              }));
            }
            jumpToMessageFinished(channel.state.messagePagination.hasNext, firstUnreadMessageId);
            if (setTargetedMessage) {
              setTargetedMessage(firstUnreadMessageId);
            }
            _context6.next = 79;
            break;
          case 76:
            _context6.prev = 76;
            _context6.t2 = _context6["catch"](1);
            console.log('Loading channel at first unread message failed with error:', _context6.t2);
          case 79:
          case "end":
            return _context6.stop();
        }
      }, _callee6, null, [[1, 76], [30, 36], [52, 63]]);
    }));
    return function loadChannelAtFirstUnreadMessage(_x5) {
      return _ref9.apply(this, arguments);
    };
  }();
  return {
    copyMessagesStateFromChannel: copyMessagesStateFromChannel,
    loadChannelAroundMessage: loadChannelAroundMessage,
    loadChannelAtFirstUnreadMessage: loadChannelAtFirstUnreadMessage,
    loadInitialMessagesStateFromChannel: loadInitialMessagesStateFromChannel,
    loadLatestMessages: loadLatestMessages,
    loadMore: loadMore,
    loadMoreRecent: loadMoreRecent,
    state: state
  };
};
//# sourceMappingURL=useMessageListPagination.js.map