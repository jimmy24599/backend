var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useNewMessage = void 0;
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var _react = require("react");
var _ChatContext = require("../../../../contexts/chatContext/ChatContext");
var _utils = require("../../utils");
var _utils2 = require("../utils");
var useNewMessage = exports.useNewMessage = function useNewMessage(_ref) {
  var lockChannelOrder = _ref.lockChannelOrder,
    onNewMessage = _ref.onNewMessage,
    options = _ref.options,
    setChannels = _ref.setChannels;
  var _useChatContext = (0, _ChatContext.useChatContext)(),
    client = _useChatContext.client;
  (0, _react.useEffect)(function () {
    var handleEvent = function handleEvent(event) {
      if (typeof onNewMessage === 'function') {
        onNewMessage(lockChannelOrder, setChannels, event, options);
      } else {
        if (!options) {
          return;
        }
        var filters = options.filters,
          sort = options.sort;
        var considerPinnedChannels = (0, _utils2.shouldConsiderPinnedChannels)(sort);
        var considerArchivedChannels = (0, _utils2.shouldConsiderArchivedChannels)(filters);
        var channelType = event.channel_type;
        var channelId = event.channel_id;
        if (!channelType || !channelId) {
          return;
        }
        setChannels(function (channels) {
          if (!channels) {
            return channels;
          }
          var targetChannel = client.channel(channelType, channelId);
          var targetChannelIndex = channels.indexOf(targetChannel);
          var isTargetChannelArchived = (0, _utils2.isChannelArchived)(targetChannel);
          var isTargetChannelPinned = (0, _utils2.isChannelPinned)(targetChannel);
          if (considerArchivedChannels && isTargetChannelArchived && !(filters != null && filters.archived) || considerArchivedChannels && !isTargetChannelArchived && filters != null && filters.archived || isTargetChannelPinned && considerPinnedChannels || lockChannelOrder) {
            return (0, _toConsumableArray2["default"])(channels);
          }
          return (0, _utils.moveChannelUp)({
            channels: channels,
            channelToMove: targetChannel,
            channelToMoveIndexWithinChannels: targetChannelIndex,
            sort: sort
          });
        });
      }
    };
    var listener = client == null ? void 0 : client.on('message.new', handleEvent);
    return function () {
      return listener == null ? void 0 : listener.unsubscribe();
    };
  }, []);
};
//# sourceMappingURL=useNewMessage.js.map