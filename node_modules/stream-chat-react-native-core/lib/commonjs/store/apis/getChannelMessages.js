var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getChannelMessages = void 0;
var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
var _selectMessagesForChannels = require("./queries/selectMessagesForChannels");
var _selectReactionsForMessages = require("./queries/selectReactionsForMessages");
var _utils = require("../../utils/utils");
var _mapStorableToMessage = require("../mappers/mapStorableToMessage");
var _createSelectQuery = require("../sqlite-utils/createSelectQuery");
var _SqliteClient = require("../SqliteClient");
var getChannelMessages = exports.getChannelMessages = function () {
  var _ref2 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee(_ref) {
    var channelIds, currentUserId, messageRows, messageIds, reactionRows, messageIdVsReactions, messageIdsVsPolls, pollsById, messagesWithPolls, polls, cidVsMessages;
    return _regenerator["default"].wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          channelIds = _ref.channelIds, currentUserId = _ref.currentUserId;
          _SqliteClient.SqliteClient.logger == null || _SqliteClient.SqliteClient.logger('info', 'getChannelMessages', {
            channelIds: channelIds,
            currentUserId: currentUserId
          });
          _context.next = 4;
          return (0, _selectMessagesForChannels.selectMessagesForChannels)(channelIds);
        case 4:
          messageRows = _context.sent;
          messageIds = messageRows.map(function (_ref3) {
            var id = _ref3.id;
            return id;
          });
          _context.next = 8;
          return (0, _selectReactionsForMessages.selectReactionsForMessages)(messageIds);
        case 8:
          reactionRows = _context.sent;
          messageIdVsReactions = {};
          reactionRows.forEach(function (reaction) {
            if (!messageIdVsReactions[reaction.messageId]) {
              messageIdVsReactions[reaction.messageId] = [];
            }
            messageIdVsReactions[reaction.messageId].push(reaction);
          });
          messageIdsVsPolls = {};
          pollsById = {};
          messagesWithPolls = messageRows.filter(function (message) {
            return !!message.poll_id;
          });
          _context.next = 16;
          return _SqliteClient.SqliteClient.executeSql.apply(null, (0, _createSelectQuery.createSelectQuery)('poll', ['*'], {
            id: messagesWithPolls.map(function (message) {
              return message.poll_id;
            })
          }));
        case 16:
          polls = _context.sent;
          polls.forEach(function (poll) {
            pollsById[poll.id] = poll;
          });
          messagesWithPolls.forEach(function (message) {
            messageIdsVsPolls[message.poll_id] = pollsById[message.poll_id];
          });
          cidVsMessages = {};
          messageRows.forEach(function (m) {
            if (!cidVsMessages[m.cid]) {
              cidVsMessages[m.cid] = [];
            }
            if (!(0, _utils.isBlockedMessage)(m)) {
              cidVsMessages[m.cid].push((0, _mapStorableToMessage.mapStorableToMessage)({
                currentUserId: currentUserId,
                messageRow: m,
                pollRow: messageIdsVsPolls[m.poll_id],
                reactionRows: messageIdVsReactions[m.id]
              }));
            }
          });
          return _context.abrupt("return", cidVsMessages);
        case 22:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return function getChannelMessages(_x) {
    return _ref2.apply(this, arguments);
  };
}();
//# sourceMappingURL=getChannelMessages.js.map